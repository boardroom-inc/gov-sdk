"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSignature = exports.generatePreValidatedSignature = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const utils_1 = require("../../utils");
const SafeSignature_1 = require("./SafeSignature");
function generatePreValidatedSignature(ownerAddress) {
    const signature = '0x000000000000000000000000' +
        ownerAddress.slice(2) +
        '0000000000000000000000000000000000000000000000000000000000000000' +
        '01';
    return new SafeSignature_1.EthSafeSignature(ownerAddress, signature);
}
exports.generatePreValidatedSignature = generatePreValidatedSignature;
async function generateSignature(ethers, signer, hash) {
    const signerAddress = await signer.getAddress();
    const messageArray = ethers.utils.arrayify(hash);
    let signature = await signer.signMessage(messageArray);
    const hasPrefix = isTxHashSignedWithPrefix(hash, signature, signerAddress);
    let signatureV = parseInt(signature.slice(-2), 16);
    switch (signatureV) {
        case 0:
        case 1:
            signatureV += 31;
            break;
        case 27:
        case 28:
            if (hasPrefix) {
                signatureV += 4;
            }
            break;
        default:
            throw new Error('Invalid signature');
    }
    signature = signature.slice(0, -2) + signatureV.toString(16);
    return new SafeSignature_1.EthSafeSignature(signerAddress, signature);
}
exports.generateSignature = generateSignature;
function isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {
    let hasPrefix;
    try {
        const rsvSig = {
            r: Buffer.from(signature.slice(2, 66), 'hex'),
            s: Buffer.from(signature.slice(66, 130), 'hex'),
            v: parseInt(signature.slice(130, 132), 16)
        };
        const recoveredData = ethereumjs_util_1.ecrecover(Buffer.from(txHash.slice(2), 'hex'), rsvSig.v, rsvSig.r, rsvSig.s);
        const recoveredAddress = ethereumjs_util_1.bufferToHex(ethereumjs_util_1.pubToAddress(recoveredData));
        hasPrefix = !utils_1.sameString(recoveredAddress, ownerAddress);
    }
    catch (e) {
        hasPrefix = true;
    }
    return hasPrefix;
}
//# sourceMappingURL=index.js.map