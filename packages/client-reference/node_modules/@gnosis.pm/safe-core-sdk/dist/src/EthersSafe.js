"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _EthersSafe_ethers, _EthersSafe_contractManager, _EthersSafe_ownerManager, _EthersSafe_moduleManager, _EthersSafe_provider, _EthersSafe_signer;
Object.defineProperty(exports, "__esModule", { value: true });
const safe_core_sdk_types_1 = require("@gnosis.pm/safe-core-sdk-types");
const ethers_1 = require("ethers");
const contractManager_1 = __importDefault(require("./managers/contractManager"));
const moduleManager_1 = __importDefault(require("./managers/moduleManager"));
const ownerManager_1 = __importDefault(require("./managers/ownerManager"));
const utils_1 = require("./utils");
const signatures_1 = require("./utils/signatures");
const gas_1 = require("./utils/transactions/gas");
const SafeTransaction_1 = __importDefault(require("./utils/transactions/SafeTransaction"));
const utils_2 = require("./utils/transactions/utils");
class EthersSafe {
    constructor() {
        _EthersSafe_ethers.set(this, void 0);
        _EthersSafe_contractManager.set(this, void 0);
        _EthersSafe_ownerManager.set(this, void 0);
        _EthersSafe_moduleManager.set(this, void 0);
        _EthersSafe_provider.set(this, void 0);
        _EthersSafe_signer.set(this, void 0);
    }
    /**
     * Creates an instance of the Safe Core SDK.
     * @param config - Ethers Safe configuration
     * @returns The Safe Core SDK instance
     * @throws "Safe contracts not found in the current network"
     * @throws "Safe Proxy contract is not deployed in the current network"
     * @throws "MultiSend contract is not deployed in the current network"
     */
    static async create({ ethers, safeAddress, providerOrSigner, contractNetworks }) {
        const safeSdk = new EthersSafe();
        await safeSdk.init({ ethers, safeAddress, providerOrSigner, contractNetworks });
        return safeSdk;
    }
    /**
     * Initializes the Safe Core SDK instance.
     * @param config - Ethers Safe configuration
     * @throws "Signer must be connected to a provider"
     * @throws "Safe contracts not found in the current network"
     * @throws "Safe Proxy contract is not deployed in the current network"
     * @throws "MultiSend contract is not deployed in the current network"
     */
    async init({ ethers, safeAddress, providerOrSigner, contractNetworks }) {
        const currentProviderOrSigner = providerOrSigner || ethers.getDefaultProvider();
        if (ethers_1.Signer.isSigner(currentProviderOrSigner)) {
            if (!currentProviderOrSigner.provider) {
                throw new Error('Signer must be connected to a provider');
            }
            __classPrivateFieldSet(this, _EthersSafe_provider, currentProviderOrSigner.provider, "f");
            __classPrivateFieldSet(this, _EthersSafe_signer, currentProviderOrSigner, "f");
        }
        else {
            __classPrivateFieldSet(this, _EthersSafe_provider, currentProviderOrSigner, "f");
            __classPrivateFieldSet(this, _EthersSafe_signer, undefined, "f");
        }
        __classPrivateFieldSet(this, _EthersSafe_ethers, ethers, "f");
        const chainId = await this.getChainId();
        __classPrivateFieldSet(this, _EthersSafe_contractManager, await contractManager_1.default.create(__classPrivateFieldGet(this, _EthersSafe_ethers, "f"), safeAddress, chainId, currentProviderOrSigner, __classPrivateFieldGet(this, _EthersSafe_provider, "f"), contractNetworks), "f");
        __classPrivateFieldSet(this, _EthersSafe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet(this, _EthersSafe_ethers, "f"), __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _EthersSafe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet(this, _EthersSafe_ethers, "f"), __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract), "f");
    }
    /**
     * Returns a new instance of the Safe Core SDK connecting the providerOrSigner and the safeAddress.
     * @param config - Connect Ethers Safe configuration
     * @throws "Safe contracts not found in the current network"
     * @throws "Safe Proxy contract is not deployed in the current network"
     * @throws "MultiSend contract is not deployed in the current network"
     */
    async connect({ providerOrSigner, safeAddress, contractNetworks }) {
        return await EthersSafe.create({
            ethers: __classPrivateFieldGet(this, _EthersSafe_ethers, "f"),
            safeAddress: safeAddress || this.getAddress(),
            providerOrSigner,
            contractNetworks
        });
    }
    /**
     * Returns the connected provider.
     *
     * @returns The connected provider
     */
    getProvider() {
        return __classPrivateFieldGet(this, _EthersSafe_provider, "f");
    }
    /**
     * Returns the connected signer.
     *
     * @returns The connected signer
     */
    getSigner() {
        return __classPrivateFieldGet(this, _EthersSafe_signer, "f");
    }
    /**
     * Returns the address of the current Safe Proxy contract.
     *
     * @returns The address of the Safe Proxy contract
     */
    getAddress() {
        return __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.address;
    }
    /**
     * Returns the address of the MultiSend contract.
     *
     * @returns The address of the MultiSend contract
     */
    getMultiSendAddress() {
        return __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").multiSendContract.address;
    }
    /**
     * Returns the Safe Master Copy contract version.
     *
     * @returns The Safe Master Copy contract version
     */
    async getContractVersion() {
        return __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.VERSION();
    }
    /**
     * Returns the list of Safe owner accounts.
     *
     * @returns The list of owners
     */
    async getOwners() {
        return __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").getOwners();
    }
    /**
     * Returns the Safe nonce.
     *
     * @returns The Safe nonce
     */
    async getNonce() {
        return (await __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.nonce()).toNumber();
    }
    /**
     * Returns the Safe threshold.
     *
     * @returns The Safe threshold
     */
    async getThreshold() {
        return __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").getThreshold();
    }
    /**
     * Returns the chainId of the connected network.
     *
     * @returns The chainId of the connected network
     */
    async getChainId() {
        return (await __classPrivateFieldGet(this, _EthersSafe_provider, "f").getNetwork()).chainId;
    }
    /**
     * Returns the ETH balance of the Safe.
     *
     * @returns The ETH balance of the Safe
     */
    async getBalance() {
        return ethers_1.BigNumber.from(await __classPrivateFieldGet(this, _EthersSafe_provider, "f").getBalance(this.getAddress()));
    }
    /**
     * Returns the list of addresses of all the enabled Safe modules.
     *
     * @returns The list of addresses of all the enabled Safe modules
     */
    async getModules() {
        return __classPrivateFieldGet(this, _EthersSafe_moduleManager, "f").getModules();
    }
    /**
     * Checks if a specific Safe module is enabled for the current Safe.
     *
     * @param moduleAddress - The desired module address
     * @returns TRUE if the module is enabled
     */
    async isModuleEnabled(moduleAddress) {
        return __classPrivateFieldGet(this, _EthersSafe_moduleManager, "f").isModuleEnabled(moduleAddress);
    }
    /**
     * Checks if a specific address is an owner of the current Safe.
     *
     * @param ownerAddress - The account address
     * @returns TRUE if the account is an owner
     */
    async isOwner(ownerAddress) {
        return __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").isOwner(ownerAddress);
    }
    /**
     * Returns a Safe transaction ready to be signed by the owners.
     *
     * @param safeTransactions - The list of transactions to process
     * @returns The Safe transaction
     */
    async createTransaction(...safeTransactions) {
        if (safeTransactions.length === 1) {
            const standardizedTransaction = await utils_2.standardizeSafeTransactionData(__classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract, safeTransactions[0]);
            return new SafeTransaction_1.default(standardizedTransaction);
        }
        const multiSendData = utils_2.encodeMultiSendData(safeTransactions.map(utils_2.standardizeMetaTransactionData));
        const multiSendTransaction = {
            to: __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").multiSendContract.address,
            value: '0',
            data: __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").multiSendContract.interface.encodeFunctionData('multiSend', [
                multiSendData
            ]),
            operation: safe_core_sdk_types_1.OperationType.DelegateCall
        };
        const standardizedTransaction = await utils_2.standardizeSafeTransactionData(__classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract, multiSendTransaction);
        return new SafeTransaction_1.default(standardizedTransaction);
    }
    /**
     * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.
     *
     * @param nonce - The nonce of the transaction/s that are going to be rejected
     * @returns The Safe transaction that invalidates the pending Safe transaction/s
     */
    async createRejectionTransaction(nonce) {
        return this.createTransaction({
            to: this.getAddress(),
            nonce,
            value: '0',
            data: '0x',
            safeTxGas: 0
        });
    }
    /**
     * Returns the transaction hash of a Safe transaction.
     *
     * @param safeTransaction - The Safe transaction
     * @returns The transaction hash of the Safe transaction
     */
    async getTransactionHash(safeTransaction) {
        const safeTransactionData = safeTransaction.data;
        const txHash = await __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce);
        return txHash;
    }
    /**
     * Signs a hash using the current signer account.
     *
     * @param hash - The hash to sign
     * @returns The Safe signature
     * @throws "No signer provided"
     * @throws "Transactions can only be signed by Safe owners"
     */
    async signTransactionHash(hash) {
        if (!__classPrivateFieldGet(this, _EthersSafe_signer, "f")) {
            throw new Error('No signer provided');
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _EthersSafe_signer, "f").getAddress();
        const addressIsOwner = owners.find((owner) => __classPrivateFieldGet(this, _EthersSafe_signer, "f") && utils_1.sameString(owner, signerAddress));
        if (!addressIsOwner) {
            throw new Error('Transactions can only be signed by Safe owners');
        }
        return signatures_1.generateSignature(__classPrivateFieldGet(this, _EthersSafe_ethers, "f"), __classPrivateFieldGet(this, _EthersSafe_signer, "f"), hash);
    }
    /**
     * Adds the signature of the current signer to the Safe transaction object.
     *
     * @param safeTransaction - The Safe transaction to be signed
     */
    async signTransaction(safeTransaction) {
        const txHash = await this.getTransactionHash(safeTransaction);
        const signature = await this.signTransactionHash(txHash);
        safeTransaction.addSignature(signature);
    }
    /**
     * Approves on-chain a hash using the current signer account.
     *
     * @param hash - The hash to approve
     * @returns The Safe transaction response
     * @throws "No signer provided"
     * @throws "Transaction hashes can only be approved by Safe owners"
     */
    async approveTransactionHash(hash) {
        if (!__classPrivateFieldGet(this, _EthersSafe_signer, "f")) {
            throw new Error('No signer provided');
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _EthersSafe_signer, "f").getAddress();
        const addressIsOwner = owners.find((owner) => __classPrivateFieldGet(this, _EthersSafe_signer, "f") && utils_1.sameString(owner, signerAddress));
        if (!addressIsOwner) {
            throw new Error('Transaction hashes can only be approved by Safe owners');
        }
        return __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.approveHash(hash);
    }
    /**
     * Returns a list of owners who have approved a specific Safe transaction.
     *
     * @param txHash - The Safe transaction hash
     * @returns The list of owners
     */
    async getOwnersWhoApprovedTx(txHash) {
        const owners = await this.getOwners();
        let ownersWhoApproved = [];
        for (const owner of owners) {
            const approved = await __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.approvedHashes(owner, txHash);
            if (approved.gt(0)) {
                ownersWhoApproved.push(owner);
            }
        }
        return ownersWhoApproved;
    }
    /**
     * Returns the Safe transaction to enable a Safe module.
     *
     * @param moduleAddress - The desired module address
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid module address provided"
     * @throws "Module provided is already enabled"
     */
    async getEnableModuleTx(moduleAddress) {
        const safeTransaction = await this.createTransaction({
            to: this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet(this, _EthersSafe_moduleManager, "f").encodeEnableModuleData(moduleAddress)
        });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to disable a Safe module.
     *
     * @param moduleAddress - The desired module address
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid module address provided"
     * @throws "Module provided is not enabled already"
     */
    async getDisableModuleTx(moduleAddress) {
        const safeTransaction = await this.createTransaction({
            to: this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet(this, _EthersSafe_moduleManager, "f").encodeDisableModuleData(moduleAddress)
        });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to add an owner and optionally change the threshold.
     *
     * @param ownerAddress - The address of the new owner
     * @param threshold - The new threshold
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid owner address provided"
     * @throws "Address provided is already an owner"
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    async getAddOwnerTx(ownerAddress, threshold) {
        const safeTransaction = await this.createTransaction({
            to: this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").encodeAddOwnerWithThresholdData(ownerAddress, threshold)
        });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to remove an owner and optionally change the threshold.
     *
     * @param ownerAddress - The address of the owner that will be removed
     * @param threshold - The new threshold
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid owner address provided"
     * @throws "Address provided is not an owner"
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    async getRemoveOwnerTx(ownerAddress, threshold) {
        const safeTransaction = await this.createTransaction({
            to: this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").encodeRemoveOwnerData(ownerAddress, threshold)
        });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to replace an owner of the Safe with a new one.
     *
     * @param oldOwnerAddress - The old owner address
     * @param newOwnerAddress - The new owner address
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid new owner address provided"
     * @throws "Invalid old owner address provided"
     * @throws "New address provided is already an owner"
     * @throws "Old address provided is not an owner"
     */
    async getSwapOwnerTx(oldOwnerAddress, newOwnerAddress) {
        const safeTransaction = await this.createTransaction({
            to: this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress)
        });
        return safeTransaction;
    }
    /**
     * Returns the Safe transaction to change the threshold.
     *
     * @param threshold - The new threshold
     * @returns The Safe transaction ready to be signed
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    async getChangeThresholdTx(threshold) {
        const safeTransaction = await this.createTransaction({
            to: this.getAddress(),
            value: '0',
            data: await __classPrivateFieldGet(this, _EthersSafe_ownerManager, "f").encodeChangeThresholdData(threshold)
        });
        return safeTransaction;
    }
    /**
     * Executes a Safe transaction.
     *
     * @param safeTransaction - The Safe transaction to execute
     * @returns The Safe transaction response
     * @throws "No signer provided"
     * @throws "There are X signatures missing"
     */
    async executeTransaction(safeTransaction) {
        if (!__classPrivateFieldGet(this, _EthersSafe_signer, "f")) {
            throw new Error('No signer provided');
        }
        const txHash = await this.getTransactionHash(safeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
            safeTransaction.addSignature(signatures_1.generatePreValidatedSignature(owner));
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _EthersSafe_signer, "f").getAddress();
        if (owners.includes(signerAddress)) {
            safeTransaction.addSignature(signatures_1.generatePreValidatedSignature(signerAddress));
        }
        const threshold = await this.getThreshold();
        if (threshold > safeTransaction.signatures.size) {
            const signaturesMissing = threshold - safeTransaction.signatures.size;
            throw new Error(`There ${signaturesMissing > 1 ? 'are' : 'is'} ${signaturesMissing} signature${signaturesMissing > 1 ? 's' : ''} missing`);
        }
        const gasLimit = await gas_1.estimateGasForTransactionExecution(__classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract, await __classPrivateFieldGet(this, _EthersSafe_signer, "f").getAddress(), safeTransaction);
        const txResponse = await __classPrivateFieldGet(this, _EthersSafe_contractManager, "f").safeContract.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), { gasLimit });
        return txResponse;
    }
}
_EthersSafe_ethers = new WeakMap(), _EthersSafe_contractManager = new WeakMap(), _EthersSafe_ownerManager = new WeakMap(), _EthersSafe_moduleManager = new WeakMap(), _EthersSafe_provider = new WeakMap(), _EthersSafe_signer = new WeakMap();
exports.default = EthersSafe;
//# sourceMappingURL=EthersSafe.js.map