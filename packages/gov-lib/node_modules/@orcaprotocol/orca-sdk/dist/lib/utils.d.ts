import { ethers } from 'ethers';
/**
 * Returns ethers contract based on name
 * @param contractName
 * @param signer
 * @returns
 */
export declare function getContract(contractName: string, signer: ethers.Signer): ethers.Contract;
/**
 * Checks to see if an address is valid (checksum or not)
 * @param address
 * @returns
 */
export declare function checkAddress(address: string): string;
/**
 * Handles ethers errors, as they have non-standard error formats.
 * @param error
 */
export declare const handleEthersError: (error: any) => never;
/**
 * Given contracts that we support, returns the encoded function data
 * @param contractName Name of contract, i.e., "ERC20". You can also use "IERC20" when relevant
 * @param functionName Name of function as it appears on the ABI, i.e., 'transfer'
 * @param args Args of function in an array.
 * @returns
 */
export declare function encodeFunctionData(contractName: string, functionName: string, args: Array<any>): string;
/**
 * Signs a message using ethers wallet and a local private key.
 * @param contractTransactionHash - Generated safe's transaction hash in the format of 0x...
 * @param signer
 * @returns Signed message based on private key.
 */
export declare function signMessage(contractTransactionHash: string, signer: ethers.Signer): Promise<string>;
/**
 * Gets the previous Controller module from the safe contract.
 * @param safe - Safe address
 * @param oldController - Old controller address
 * @param newController - New controller address
 * @param signer
 * @returns
 */
export declare function getPreviousModule(safe: string, oldController: string, newController: string, signer: ethers.Signer): Promise<string>;
