import { Provider } from '@ethersproject/providers';
import { SafeSignature, SafeTransaction, SafeTransactionDataPartial } from '@gnosis.pm/safe-core-sdk-types';
import { BigNumber, ContractTransaction, Signer } from 'ethers';
import Safe, { ConnectEthersSafeConfig, EthersSafeConfig } from './Safe';
declare class EthersSafe implements Safe {
    #private;
    /**
     * Creates an instance of the Safe Core SDK.
     * @param config - Ethers Safe configuration
     * @returns The Safe Core SDK instance
     * @throws "Safe contracts not found in the current network"
     * @throws "Safe Proxy contract is not deployed in the current network"
     * @throws "MultiSend contract is not deployed in the current network"
     */
    static create({ ethers, safeAddress, providerOrSigner, contractNetworks }: EthersSafeConfig): Promise<EthersSafe>;
    /**
     * Initializes the Safe Core SDK instance.
     * @param config - Ethers Safe configuration
     * @throws "Signer must be connected to a provider"
     * @throws "Safe contracts not found in the current network"
     * @throws "Safe Proxy contract is not deployed in the current network"
     * @throws "MultiSend contract is not deployed in the current network"
     */
    private init;
    /**
     * Returns a new instance of the Safe Core SDK connecting the providerOrSigner and the safeAddress.
     * @param config - Connect Ethers Safe configuration
     * @throws "Safe contracts not found in the current network"
     * @throws "Safe Proxy contract is not deployed in the current network"
     * @throws "MultiSend contract is not deployed in the current network"
     */
    connect({ providerOrSigner, safeAddress, contractNetworks }: ConnectEthersSafeConfig): Promise<EthersSafe>;
    /**
     * Returns the connected provider.
     *
     * @returns The connected provider
     */
    getProvider(): Provider;
    /**
     * Returns the connected signer.
     *
     * @returns The connected signer
     */
    getSigner(): Signer | undefined;
    /**
     * Returns the address of the current Safe Proxy contract.
     *
     * @returns The address of the Safe Proxy contract
     */
    getAddress(): string;
    /**
     * Returns the address of the MultiSend contract.
     *
     * @returns The address of the MultiSend contract
     */
    getMultiSendAddress(): string;
    /**
     * Returns the Safe Master Copy contract version.
     *
     * @returns The Safe Master Copy contract version
     */
    getContractVersion(): Promise<string>;
    /**
     * Returns the list of Safe owner accounts.
     *
     * @returns The list of owners
     */
    getOwners(): Promise<string[]>;
    /**
     * Returns the Safe nonce.
     *
     * @returns The Safe nonce
     */
    getNonce(): Promise<number>;
    /**
     * Returns the Safe threshold.
     *
     * @returns The Safe threshold
     */
    getThreshold(): Promise<number>;
    /**
     * Returns the chainId of the connected network.
     *
     * @returns The chainId of the connected network
     */
    getChainId(): Promise<number>;
    /**
     * Returns the ETH balance of the Safe.
     *
     * @returns The ETH balance of the Safe
     */
    getBalance(): Promise<BigNumber>;
    /**
     * Returns the list of addresses of all the enabled Safe modules.
     *
     * @returns The list of addresses of all the enabled Safe modules
     */
    getModules(): Promise<string[]>;
    /**
     * Checks if a specific Safe module is enabled for the current Safe.
     *
     * @param moduleAddress - The desired module address
     * @returns TRUE if the module is enabled
     */
    isModuleEnabled(moduleAddress: string): Promise<boolean>;
    /**
     * Checks if a specific address is an owner of the current Safe.
     *
     * @param ownerAddress - The account address
     * @returns TRUE if the account is an owner
     */
    isOwner(ownerAddress: string): Promise<boolean>;
    /**
     * Returns a Safe transaction ready to be signed by the owners.
     *
     * @param safeTransactions - The list of transactions to process
     * @returns The Safe transaction
     */
    createTransaction(...safeTransactions: SafeTransactionDataPartial[]): Promise<SafeTransaction>;
    /**
     * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.
     *
     * @param nonce - The nonce of the transaction/s that are going to be rejected
     * @returns The Safe transaction that invalidates the pending Safe transaction/s
     */
    createRejectionTransaction(nonce: number): Promise<SafeTransaction>;
    /**
     * Returns the transaction hash of a Safe transaction.
     *
     * @param safeTransaction - The Safe transaction
     * @returns The transaction hash of the Safe transaction
     */
    getTransactionHash(safeTransaction: SafeTransaction): Promise<string>;
    /**
     * Signs a hash using the current signer account.
     *
     * @param hash - The hash to sign
     * @returns The Safe signature
     * @throws "No signer provided"
     * @throws "Transactions can only be signed by Safe owners"
     */
    signTransactionHash(hash: string): Promise<SafeSignature>;
    /**
     * Adds the signature of the current signer to the Safe transaction object.
     *
     * @param safeTransaction - The Safe transaction to be signed
     */
    signTransaction(safeTransaction: SafeTransaction): Promise<void>;
    /**
     * Approves on-chain a hash using the current signer account.
     *
     * @param hash - The hash to approve
     * @returns The Safe transaction response
     * @throws "No signer provided"
     * @throws "Transaction hashes can only be approved by Safe owners"
     */
    approveTransactionHash(hash: string): Promise<ContractTransaction>;
    /**
     * Returns a list of owners who have approved a specific Safe transaction.
     *
     * @param txHash - The Safe transaction hash
     * @returns The list of owners
     */
    getOwnersWhoApprovedTx(txHash: string): Promise<string[]>;
    /**
     * Returns the Safe transaction to enable a Safe module.
     *
     * @param moduleAddress - The desired module address
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid module address provided"
     * @throws "Module provided is already enabled"
     */
    getEnableModuleTx(moduleAddress: string): Promise<SafeTransaction>;
    /**
     * Returns the Safe transaction to disable a Safe module.
     *
     * @param moduleAddress - The desired module address
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid module address provided"
     * @throws "Module provided is not enabled already"
     */
    getDisableModuleTx(moduleAddress: string): Promise<SafeTransaction>;
    /**
     * Returns the Safe transaction to add an owner and optionally change the threshold.
     *
     * @param ownerAddress - The address of the new owner
     * @param threshold - The new threshold
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid owner address provided"
     * @throws "Address provided is already an owner"
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    getAddOwnerTx(ownerAddress: string, threshold?: number): Promise<SafeTransaction>;
    /**
     * Returns the Safe transaction to remove an owner and optionally change the threshold.
     *
     * @param ownerAddress - The address of the owner that will be removed
     * @param threshold - The new threshold
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid owner address provided"
     * @throws "Address provided is not an owner"
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    getRemoveOwnerTx(ownerAddress: string, threshold?: number): Promise<SafeTransaction>;
    /**
     * Returns the Safe transaction to replace an owner of the Safe with a new one.
     *
     * @param oldOwnerAddress - The old owner address
     * @param newOwnerAddress - The new owner address
     * @returns The Safe transaction ready to be signed
     * @throws "Invalid new owner address provided"
     * @throws "Invalid old owner address provided"
     * @throws "New address provided is already an owner"
     * @throws "Old address provided is not an owner"
     */
    getSwapOwnerTx(oldOwnerAddress: string, newOwnerAddress: string): Promise<SafeTransaction>;
    /**
     * Returns the Safe transaction to change the threshold.
     *
     * @param threshold - The new threshold
     * @returns The Safe transaction ready to be signed
     * @throws "Threshold needs to be greater than 0"
     * @throws "Threshold cannot exceed owner count"
     */
    getChangeThresholdTx(threshold: number): Promise<SafeTransaction>;
    /**
     * Executes a Safe transaction.
     *
     * @param safeTransaction - The Safe transaction to execute
     * @returns The Safe transaction response
     * @throws "No signer provided"
     * @throws "There are X signatures missing"
     */
    executeTransaction(safeTransaction: SafeTransaction): Promise<ContractTransaction>;
}
export default EthersSafe;
