"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var ethers_1 = require("ethers");
var axios_1 = __importDefault(require("axios"));
var contracts_1 = require("@orcaprotocol/contracts");
var config_1 = require("./config");
var fetchers_1 = require("./fetchers");
var utils_1 = require("./lib/utils");
var transaction_service_1 = require("./lib/services/transaction-service");
var Proposal_1 = __importDefault(require("./Proposal"));
/**
 * The `Pod` object is the interface for fetching pod data.
 *
 * The Pod object should not be instantiated directly, use {@link getPod} instead.
 *
 * The following properties are on the object itself:
 *
 * ```js
 * const {
 *   id, // Pod ID
 *   safe, // Gnosis safe address, aka the Pod address
 *   ensName, // E.g., orcanauts.pod.xyz
 *   admin, // Address of pod admin
 *   imageUrl, // Source of NFT image
 *   imageNoTextUrl, // Source of NFT image without text (used for avatars)
 * } = await getPod();
 * ```
 *
 * Members, EOAs and member Pods can be fetched with the following functions:
 *
 * ```js
 * const pod = await getPod(podAddress);
 * // Fetches list of all members from the pod, as an array of Ethereum addresses.
 * // This includes any pods that may be members of the original pods.
 * const members = await pod.getMembers();
 *
 * // Fetches any member EOAs (externally owned accounts). That is, any member that is not a smart contract or pod.
 * const memberEOAs = await pod.getMemberEOAs();
 *
 * // Fetches Pod objects for any member pods.
 * const memberPods = await pod.getMemberPods();
 * ```
 *
 * You can also check if a user is a member, admin, or member of those pods with the following functions:
 *
 * ```js
 * const pod = await getPod(podAddress);
 *
 * const isMember = await pod.isMember(userAddress);
 * // Not an async function
 * const isAdmin = pod.isAdmin(userAddress);
 *
 * const isAdminPodMember = await pod.isAdminPodMember(userAddress);
 *
 * // Includes both pods and users as sub pod members.
 * const isSubPodMember = await pod.isSubPodMember(userAddress);
 * ```
 */
var Pod = /** @class */ (function () {
    /**
     *  Note this constructor should not be called directly. Use `getPod()` instead.
     * @param identifier Can be either podId or safe address
     */
    function Pod(identifier) {
        var _this = this;
        /**
         * Returns an array of Proposal objects in reverse chronological order. Defaults to returning 5,
         * which can be overridden by passing { limit: 10 } for example in the options.
         *
         * By default, the first Proposal will be the active proposal. Queued proposals can be fetched
         * by passing { queued: true } in the options. This will return any queued proposals, as well any proposals
         * that follow (such as active or executed proposals)
         *
         * @param options
         * @returns
         */
        this.getProposals = function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var _a, nonce, threshold, _b, limit, params, safeTransactions, _c, _d, normalTransactions, rejectTransactions, rejectNonces;
                var _this = this;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0: return [4 /*yield*/, (0, transaction_service_1.getSafeInfo)(this.safe)];
                        case 1:
                            _a = _e.sent(), nonce = _a.nonce, threshold = _a.threshold;
                            this.threshold = threshold;
                            _b = options.limit, limit = _b === void 0 ? 5 : _b;
                            params = options.queued ? { nonce_gte: nonce, limit: limit } : { limit: limit };
                            _d = (_c = Promise).all;
                            return [4 /*yield*/, (0, transaction_service_1.getSafeTransactionsBySafe)(this.safe, params)];
                        case 2: return [4 /*yield*/, _d.apply(_c, [(_e.sent()).map(function (tx) {
                                    return (0, transaction_service_1.populateDataDecoded)(__assign(__assign({}, tx), { confirmationsRequired: threshold }));
                                })])];
                        case 3:
                            safeTransactions = _e.sent();
                            normalTransactions = [];
                            rejectTransactions = [];
                            safeTransactions.forEach(function (tx) {
                                if (tx.data === null && tx.to === _this.safe) {
                                    return rejectTransactions.push(tx);
                                }
                                return normalTransactions.push(tx);
                            });
                            rejectNonces = rejectTransactions.map(function (tx) { return tx.nonce; });
                            return [2 /*return*/, Promise.all(normalTransactions.map(function (tx) {
                                    // Check to see if there is a corresponding reject nonce.
                                    var rejectNonceIndex = rejectNonces.indexOf(tx.nonce);
                                    // If there is, we package that together with the regular transaction.
                                    if (rejectNonceIndex >= 0) {
                                        return new Proposal_1["default"](_this, nonce, tx, rejectTransactions[rejectNonceIndex]);
                                    }
                                    // Otherwise, just handle it normally.
                                    return new Proposal_1["default"](_this, nonce, tx);
                                }))];
                    }
                });
            });
        };
        /**
         * Returns of list of all member addresses.
         * Members include member pods and member EOAs
         */
        this.getMembers = function () { return __awaiter(_this, void 0, void 0, function () {
            var subgraphUrl, data, users;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subgraphUrl = config_1.config.subgraphUrl;
                        if (this.members)
                            return [2 /*return*/, this.members];
                        return [4 /*yield*/, axios_1["default"].post(subgraphUrl, {
                                query: "query GetPodUsers($id: ID!) {\n            pod(id: $id) {\n              users {\n                user {\n                  id\n                }\n              }\n            }\n          }",
                                variables: { id: this.id }
                            })];
                    case 1:
                        data = (_a.sent()).data;
                        users = (data.data.pod || { users: [] }).users;
                        // Checksum all addresses.
                        this.members = users.length > 0 ? users.map(function (user) { return ethers_1.ethers.utils.getAddress(user.user.id); }) : [];
                        return [2 /*return*/, this.members];
                }
            });
        }); };
        /**
         * Returns list of all member EOAs, not including any smart contract/pod members.
         */
        this.getMemberEOAs = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.memberEOAs)
                            return [2 /*return*/, this.memberEOAs];
                        return [4 /*yield*/, this.populateMembers()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.memberEOAs];
                }
            });
        }); };
        /**
         * Returns Pod objects of all member pods.
         */
        this.getMemberPods = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.memberPods)
                            return [2 /*return*/, this.memberPods];
                        return [4 /*yield*/, this.populateMembers()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.memberPods];
                }
            });
        }); };
        /**
         * Checks if user is a member of this pod
         * @param address
         */
        this.isMember = function (address) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(address);
                        if (!!this.members) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getMembers()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, this.members.includes(checkedAddress)];
                }
            });
        }); };
        /**
         * Checks if user is admin of this pod
         * @param address
         */
        this.isAdmin = function (address) {
            var checkedAddress = (0, utils_1.checkAddress)(address);
            return checkedAddress === _this.admin;
        };
        /**
         * Checks if given address is a member of the admin pod (if there is one)
         * Returns false if there is no admin pod.
         */
        this.isAdminPodMember = function (address) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, adminPod;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(address);
                        if (!this.admin)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, new Pod(this.admin)];
                    case 1:
                        adminPod = _a.sent();
                        if (!adminPod)
                            return [2 /*return*/, false];
                        return [2 /*return*/, adminPod.isMember(checkedAddress)];
                }
            });
        }); };
        /**
         * Checks if given address is a member of any subpods.
         *
         * Returns false if the user is a member of **this** pod, but not any sub pods
         *
         * @param address
         */
        this.isSubPodMember = function (address) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(address);
                        if (!!this.memberPods) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.populateMembers()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, Promise.all(this.memberPods.map(function (pod) { return __awaiter(_this, void 0, void 0, function () {
                            var members;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, pod.getMembers()];
                                    case 1:
                                        members = _a.sent();
                                        return [2 /*return*/, members.includes(checkedAddress)];
                                }
                            });
                        }); }))];
                    case 3:
                        results = _a.sent();
                        return [2 /*return*/, results.includes(true)];
                }
            });
        }); };
        /**
         * Mints member to this pod.
         * @throws if signer is not admin TODO
         */
        this.mintMember = function (newMember, signer) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                (0, utils_1.checkAddress)(newMember);
                try {
                    return [2 /*return*/, (0, utils_1.getContract)('MemberToken', signer).mint(newMember, this.id, ethers_1.ethers.constants.HashZero)];
                }
                catch (err) {
                    return [2 /*return*/, (0, utils_1.handleEthersError)(err)];
                }
                return [2 /*return*/];
            });
        }); };
        /**
         * Burns member from this pod.
         * @throws If signer is not admin TODO
         */
        this.burnMember = function (memberToBurn, signer) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                (0, utils_1.checkAddress)(memberToBurn);
                try {
                    return [2 /*return*/, (0, utils_1.getContract)('MemberToken', signer).burn(memberToBurn, this.id)];
                }
                catch (err) {
                    return [2 /*return*/, (0, utils_1.handleEthersError)(err)];
                }
                return [2 /*return*/];
            });
        }); };
        /**
         * Transfers a membership from the signer's account to the memberToTransferTo.
         *
         * @param addressToTransferTo - Address that will receive new membership
         * @param signer - Signer of the address that is giving up membership
         * @throws If addressToTransferTo is already a member TODO
         * @throws If signer is not admin TODO
         */
        this.transferMembership = function (addressToTransferTo, signer) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, signerAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(addressToTransferTo);
                        return [4 /*yield*/, this.isMember(checkedAddress)];
                    case 1:
                        if (_a.sent()) {
                            throw new Error("Address ".concat(checkedAddress, " is already a member of this pod"));
                        }
                        return [4 /*yield*/, signer.getAddress()];
                    case 2:
                        signerAddress = _a.sent();
                        return [4 /*yield*/, this.isMember(signerAddress)];
                    case 3:
                        if (!(_a.sent())) {
                            throw new Error("Signer ".concat(signerAddress, " is not a member of this pod"));
                        }
                        try {
                            return [2 /*return*/, (0, utils_1.getContract)('MemberToken', signer).safeTransferFrom(signerAddress, checkedAddress, this.id, 1, ethers_1.ethers.constants.HashZero)];
                        }
                        catch (err) {
                            return [2 /*return*/, (0, utils_1.handleEthersError)(err)];
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        /**
         * Transfers admin role from signer's account to addressToTransferTo
         * @param addressToTransferTo - Address that will receive admin role
         * @param signer - Signer of admin
         * @throws If signer is not admin
         */
        this.transferAdmin = function (addressToTransferTo, signer) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, signerAddress, controllerAbi, Controller;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(addressToTransferTo);
                        return [4 /*yield*/, signer.getAddress()];
                    case 1:
                        signerAddress = _a.sent();
                        if (!this.isAdmin(signerAddress))
                            throw new Error('Signer was not the admin of this pod');
                        controllerAbi = (0, contracts_1.getControllerByAddress)(this.controller, config_1.config.network).abi;
                        Controller = new ethers_1.ethers.Contract(this.controller, controllerAbi, signer);
                        try {
                            return [2 /*return*/, Controller.updatePodAdmin(this.id, checkedAddress)];
                        }
                        catch (err) {
                            return [2 /*return*/, (0, utils_1.handleEthersError)(err)];
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates a proposal to mint a member to this pod
         * @param newMember
         * @param signer - Signer of pod member
         * @throws If new member is part of this pod.
         * @throws If signer is not part of this pod. TODO
         */
        this.proposeMintMember = function (newMember, signer) { return __awaiter(_this, void 0, void 0, function () {
            var data, memberTokenAddress, memberAddress, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        (0, utils_1.checkAddress)(newMember);
                        return [4 /*yield*/, this.isMember(newMember)];
                    case 1:
                        if (_a.sent()) {
                            throw new Error("Address ".concat(newMember, " is already in this pod"));
                        }
                        data = (0, utils_1.encodeFunctionData)('MemberToken', 'mint', [
                            ethers_1.ethers.utils.getAddress(newMember),
                            this.id,
                            ethers_1.ethers.constants.HashZero,
                        ]);
                        memberTokenAddress = (0, utils_1.getContract)('MemberToken', signer).address;
                        return [4 /*yield*/, signer.getAddress()];
                    case 2:
                        memberAddress = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: memberAddress,
                                safe: this.safe,
                                to: memberTokenAddress,
                                data: data
                            }, signer)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        err_1 = _a.sent();
                        throw new Error(err_1);
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates a proposal on an external pod to mint a new member to this pod.
         * @param externalPodIdentifier - The Pod object, pod ID or pod safe address of either the admin pod, or a subpod of this pod.
         * @param newMember - Member to mint
         * @param signer - Signer of external pod member
         * @throws If newMember is already part of this pod
         * @throws If externalPodIdentifier does not correlate to existing pod
         * @throws If externalPodIdentifier is not the admin or subpod of this pod
         * @throws If signer is not a member of external pod
         */
        this.proposeMintMemberFromPod = function (externalPodIdentifier, newMember, signer) { return __awaiter(_this, void 0, void 0, function () {
            var externalPod, _a, signerAddress, data, memberTokenAddress, err_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.isMember(newMember)];
                    case 1:
                        if (_b.sent()) {
                            throw new Error("Address ".concat(newMember, " is already in this pod"));
                        }
                        if (!(externalPodIdentifier instanceof Pod)) return [3 /*break*/, 2];
                        externalPod = externalPodIdentifier;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, new Pod(externalPodIdentifier)];
                    case 3:
                        externalPod = _b.sent();
                        _b.label = 4;
                    case 4:
                        if (!externalPod)
                            throw new Error("Could not find a pod with identifier ".concat(externalPodIdentifier));
                        _a = this.isAdmin(externalPod.safe);
                        if (_a) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.isMember(externalPod.safe)];
                    case 5:
                        _a = (_b.sent());
                        _b.label = 6;
                    case 6:
                        // External pod must be the admin or a subpod of this pod.
                        if (!(_a)) {
                            throw new Error("Pod ".concat(externalPod.safe, " must be the admin or a subpod of this pod to make proposals"));
                        }
                        return [4 /*yield*/, signer.getAddress()];
                    case 7:
                        signerAddress = _b.sent();
                        return [4 /*yield*/, externalPod.isMember(signerAddress)];
                    case 8:
                        if (!(_b.sent()))
                            throw new Error("Signer ".concat(signerAddress, " was not a member of the external pod"));
                        data = (0, utils_1.encodeFunctionData)('MemberToken', 'mint', [
                            ethers_1.ethers.utils.getAddress(newMember),
                            this.id,
                            ethers_1.ethers.constants.HashZero,
                        ]);
                        memberTokenAddress = (0, utils_1.getContract)('MemberToken', signer).address;
                        _b.label = 9;
                    case 9:
                        _b.trys.push([9, 11, , 12]);
                        // Create a safe transaction on this pod, sent from the admin pod
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: externalPod.safe,
                                safe: this.safe,
                                to: memberTokenAddress,
                                data: data
                            }, signer)];
                    case 10:
                        // Create a safe transaction on this pod, sent from the admin pod
                        _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        err_2 = _b.sent();
                        throw new Error(err_2);
                    case 12: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates a proposal to burn a member from this pod
         * @param memberToBurn - Member to remove from this pod
         * @param signer - Signer of pod member
         * @throws If memberToBurn is not part of this pod
         */
        this.proposeBurnMember = function (memberToBurn, signer) { return __awaiter(_this, void 0, void 0, function () {
            var data, memberTokenAddress, memberAddress, err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        (0, utils_1.checkAddress)(memberToBurn);
                        return [4 /*yield*/, this.isMember(memberToBurn)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error("Address ".concat(memberToBurn, " is not in this pod"));
                        }
                        data = (0, utils_1.encodeFunctionData)('MemberToken', 'burn', [
                            ethers_1.ethers.utils.getAddress(memberToBurn),
                            this.id,
                        ]);
                        memberTokenAddress = (0, utils_1.getContract)('MemberToken', signer).address;
                        return [4 /*yield*/, signer.getAddress()];
                    case 2:
                        memberAddress = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: memberAddress,
                                safe: this.safe,
                                to: memberTokenAddress,
                                data: data
                            }, signer)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        err_3 = _a.sent();
                        throw new Error(err_3);
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates a proposal on an external pod to burn a new member from this pod.
         * @param externalPodIdentifier - The Pod object, pod ID or pod safe address of either the admin pod, or a subpod of this pod.
         * @param memberToBurn - Member to burn
         * @param signer - Signer of external pod member
         * @throws If memberToBurn is not part of this pod
         * @throws If externalPodIdentifier is not an existing pod
         * @throws If externalPodIdentifier is not the admin or subpod of this pod
         * @throws If Signer is not a member of the external pod
         */
        this.proposeBurnMemberFromPod = function (externalPodIdentifier, memberToBurn, signer) { return __awaiter(_this, void 0, void 0, function () {
            var externalPod, _a, signerAddress, data, memberTokenAddress, err_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.isMember(memberToBurn)];
                    case 1:
                        if (!(_b.sent())) {
                            throw new Error("Address ".concat(memberToBurn, " is not in this pod"));
                        }
                        if (!(externalPodIdentifier instanceof Pod)) return [3 /*break*/, 2];
                        externalPod = externalPodIdentifier;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, new Pod(externalPodIdentifier)];
                    case 3:
                        externalPod = _b.sent();
                        _b.label = 4;
                    case 4:
                        if (!externalPod)
                            throw new Error("Could not find a pod with identifier ".concat(externalPodIdentifier));
                        _a = this.isAdmin(externalPod.safe);
                        if (_a) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.isMember(externalPod.safe)];
                    case 5:
                        _a = (_b.sent());
                        _b.label = 6;
                    case 6:
                        // External pod must be the admin or a subpod of this pod.
                        if (!(_a)) {
                            throw new Error("Pod ".concat(externalPod.safe, " must be the admin or a subpod of this pod to make proposals"));
                        }
                        return [4 /*yield*/, signer.getAddress()];
                    case 7:
                        signerAddress = _b.sent();
                        return [4 /*yield*/, externalPod.isMember(signerAddress)];
                    case 8:
                        if (!(_b.sent()))
                            throw new Error("Signer ".concat(signerAddress, " was not a member of the external pod"));
                        data = (0, utils_1.encodeFunctionData)('MemberToken', 'burn', [
                            ethers_1.ethers.utils.getAddress(memberToBurn),
                            this.id,
                        ]);
                        memberTokenAddress = (0, utils_1.getContract)('MemberToken', signer).address;
                        _b.label = 9;
                    case 9:
                        _b.trys.push([9, 11, , 12]);
                        // Create a safe transaction on this pod, sent from the admin pod
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: externalPod.safe,
                                safe: this.safe,
                                to: memberTokenAddress,
                                data: data
                            }, signer)];
                    case 10:
                        // Create a safe transaction on this pod, sent from the admin pod
                        _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        err_4 = _b.sent();
                        throw new Error(err_4);
                    case 12: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates a proposal to transfer membership from a subpod
         * @param subPodIdentifier - Pod, Pod ID or safe address
         * @param addressToTransferTo - Address that will receive the membership
         * @param signer - Signer of subpod member
         * @throws If addressToTransferTo is already a member of this pod
         * @throws If subPodIdentifier does not exist
         * @throws If Signer is not a member of this sub pod
         */
        this.proposeTransferMembershipFromSubPod = function (subPodIdentifier, addressToTransferTo, signer) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, subPod, signerAddress, data, memberTokenAddress, err_5;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(addressToTransferTo);
                        return [4 /*yield*/, this.isMember(addressToTransferTo)];
                    case 1:
                        if (_a.sent()) {
                            throw new Error("Address ".concat(addressToTransferTo, " is already in this pod"));
                        }
                        if (!(subPodIdentifier instanceof Pod)) return [3 /*break*/, 2];
                        subPod = subPodIdentifier;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, new Pod(subPodIdentifier)];
                    case 3:
                        subPod = _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!subPod)
                            throw new Error("Could not find a pod with identifier ".concat(subPodIdentifier));
                        return [4 /*yield*/, this.isMember(subPod.safe)];
                    case 5:
                        // Sub pod must be the admin or a subpod of this pod.
                        if (!(_a.sent())) {
                            throw new Error("Pod ".concat(subPod.ensName, " must be a subpod of this pod to make proposals"));
                        }
                        return [4 /*yield*/, signer.getAddress()];
                    case 6:
                        signerAddress = _a.sent();
                        return [4 /*yield*/, subPod.isMember(signerAddress)];
                    case 7:
                        if (!(_a.sent()))
                            throw new Error("Signer ".concat(signerAddress, " was not a member of sub pod ").concat(subPod.ensName));
                        data = (0, utils_1.encodeFunctionData)('MemberToken', 'safeTransferFrom', [
                            subPod.safe,
                            checkedAddress,
                            this.id,
                            1,
                            ethers_1.ethers.constants.HashZero,
                        ]);
                        memberTokenAddress = (0, utils_1.getContract)('MemberToken', signer).address;
                        _a.label = 8;
                    case 8:
                        _a.trys.push([8, 10, , 11]);
                        // Create a safe transaction on this pod, sent from the admin pod
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: subPod.safe,
                                safe: this.safe,
                                to: memberTokenAddress,
                                data: data
                            }, signer)];
                    case 9:
                        // Create a safe transaction on this pod, sent from the admin pod
                        _a.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        err_5 = _a.sent();
                        throw new Error(err_5);
                    case 11: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates proposal to transfer the admin role from the admin pod
         * @param adminPodIdentifier - Pod ID, safe address, or ENS name of admin pod
         * @param addressToTransferTo - Address that will receive admin roll
         * @param signer - Signer of admin pod member
         * @throws If addressToTransferTo is already the pod admin
         * @throws If adminPodIdentifier does not exist
         * @throws If adminPodIdentifier is not the admin of this pod
         * @throws If Signer is not a member of the admin pod
         */
        this.proposeTransferAdminFromAdminPod = function (adminPodIdentifier, addressToTransferTo, signer) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, adminPod, signerAddress, controllerAbi, data, err_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(addressToTransferTo);
                        if (this.isAdmin(addressToTransferTo)) {
                            throw new Error("Address ".concat(addressToTransferTo, " is already pod admin"));
                        }
                        if (!(adminPodIdentifier instanceof Pod)) return [3 /*break*/, 1];
                        adminPod = adminPodIdentifier;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, new Pod(adminPodIdentifier)];
                    case 2:
                        adminPod = _a.sent();
                        _a.label = 3;
                    case 3:
                        if (!adminPod)
                            throw new Error("Could not find a pod with identifier ".concat(adminPodIdentifier));
                        if (!this.isAdmin(adminPod.safe)) {
                            throw new Error("Pod ".concat(adminPod.ensName, " must be the admin of this pod"));
                        }
                        return [4 /*yield*/, signer.getAddress()];
                    case 4:
                        signerAddress = _a.sent();
                        return [4 /*yield*/, adminPod.isMember(signerAddress)];
                    case 5:
                        if (!(_a.sent()))
                            throw new Error("Signer ".concat(signerAddress, " was not a member of admin pod ").concat(adminPod.ensName));
                        controllerAbi = (0, contracts_1.getControllerByAddress)(this.controller, config_1.config.network).abi;
                        data = new ethers_1.ethers.utils.Interface(controllerAbi).encodeFunctionData('updatePodAdmin', [
                            this.id,
                            checkedAddress,
                        ]);
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        // Create a safe transaction on this pod, sent from the admin pod
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: adminPod.safe,
                                safe: this.safe,
                                to: this.controller,
                                data: data
                            }, signer)];
                    case 7:
                        // Create a safe transaction on this pod, sent from the admin pod
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        err_6 = _a.sent();
                        throw new Error(err_6);
                    case 9: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Adds newAdminAddress as the admin of this pod, if this pod does not currently have an admin.
         * @param newAdminAddress - Address of new admin
         * @param signer - Signer of pod member
         * @throws If pod already has an admin
         */
        this.proposeAddAdmin = function (newAdminAddress, signer) { return __awaiter(_this, void 0, void 0, function () {
            var checkedAddress, signerAddress, controllerAbi, data, err_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        checkedAddress = (0, utils_1.checkAddress)(newAdminAddress);
                        return [4 /*yield*/, signer.getAddress()];
                    case 1:
                        signerAddress = _a.sent();
                        if (this.admin)
                            throw new Error('Pod already has admin');
                        controllerAbi = (0, contracts_1.getControllerByAddress)(this.controller, config_1.config.network).abi;
                        data = new ethers_1.ethers.utils.Interface(controllerAbi).encodeFunctionData('updatePodAdmin', [
                            this.id,
                            checkedAddress,
                        ]);
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        // Create a proposal from the signer address
                        return [4 /*yield*/, (0, transaction_service_1.createSafeTransaction)({
                                sender: signerAddress,
                                safe: this.safe,
                                to: this.controller,
                                data: data
                            }, signer)];
                    case 3:
                        // Create a proposal from the signer address
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        err_7 = _a.sent();
                        throw new Error(err_7);
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Migrates the pod to the latest version. Signer must be the admin of pod.
         * @param signer - Signer of pod admin
         * @throws If signer is not pod admin TODO
         */
        this.migratePodToLatest = function (signer) { return __awaiter(_this, void 0, void 0, function () {
            var newController, oldControllerDeployment, OldController, previousModule, res, err_8;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newController = (0, contracts_1.getDeployment)('ControllerLatest', config_1.config.network);
                        oldControllerDeployment = (0, contracts_1.getControllerByAddress)(this.controller, config_1.config.network);
                        OldController = new ethers_1.ethers.Contract(oldControllerDeployment.address, oldControllerDeployment.abi, signer);
                        return [4 /*yield*/, (0, utils_1.getPreviousModule)(this.safe, oldControllerDeployment.address, newController.address, signer)];
                    case 1:
                        previousModule = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, OldController.migratePodController(this.id, newController.address, previousModule)];
                    case 3:
                        res = _a.sent();
                        return [2 /*return*/, res];
                    case 4:
                        err_8 = _a.sent();
                        return [2 /*return*/, (0, utils_1.handleEthersError)(err_8)];
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Creates a proposal to migrate the pod to the latest version.
         * @param signer - Signer of pod member
         * @throws If signer is not a pod member TODO
         */
        this.proposeMigratePodToLatest = function (signer) { return __awaiter(_this, void 0, void 0, function () {
            var newController, oldController, previousModule, data, _a, err_9;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        newController = (0, contracts_1.getDeployment)('ControllerLatest', config_1.config.network);
                        oldController = (0, contracts_1.getControllerByAddress)(this.controller, config_1.config.network);
                        return [4 /*yield*/, (0, utils_1.getPreviousModule)(this.safe, oldController.address, newController.address, signer)];
                    case 1:
                        previousModule = _c.sent();
                        data = new ethers_1.ethers.utils.Interface(oldController.abi).encodeFunctionData('migratePodController', [this.id, newController.address, previousModule]);
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 5, , 6]);
                        _a = transaction_service_1.createSafeTransaction;
                        _b = {};
                        return [4 /*yield*/, signer.getAddress()];
                    case 3: return [4 /*yield*/, _a.apply(void 0, [(_b.sender = _c.sent(),
                                _b.safe = this.safe,
                                _b.to = oldController.address,
                                _b.data = data,
                                _b), signer])];
                    case 4:
                        _c.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        err_9 = _c.sent();
                        throw new Error(err_9);
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        var network = config_1.config.network;
        // This is a kind of hacky way to go about an async constructor.
        // It works, typescript just doesn't like it.
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        return (function () { return __awaiter(_this, void 0, void 0, function () {
            var podId, safe, Controller, Name, fetchers, err_10, fetchedAdmin, baseUrl, imageUrl, imageNoTextUrl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        fetchers = void 0;
                        if (!(typeof identifier === 'string')) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, fetchers_1.getPodFetchersByAddressOrEns)(identifier)];
                    case 1:
                        fetchers = _a.sent();
                        return [3 /*break*/, 4];
                    case 2:
                        if (!(typeof identifier === 'number')) return [3 /*break*/, 4];
                        return [4 /*yield*/, (0, fetchers_1.getPodFetchersById)(identifier)];
                    case 3:
                        fetchers = _a.sent();
                        _a.label = 4;
                    case 4:
                        podId = fetchers.podId;
                        safe = fetchers.safe;
                        Controller = fetchers.Controller;
                        Name = fetchers.Name;
                        return [3 /*break*/, 6];
                    case 5:
                        err_10 = _a.sent();
                        if (err_10.message.includes('invalid address')) {
                            throw new TypeError("Non-address string passed to Pod constructor: '".concat(identifier, "'"));
                        }
                        return [2 /*return*/, null];
                    case 6: return [4 /*yield*/, Controller.podAdmin(podId)];
                    case 7:
                        fetchedAdmin = _a.sent();
                        this.controller = Controller.address;
                        this.admin = fetchedAdmin === ethers_1.ethers.constants.AddressZero ? null : fetchedAdmin;
                        this.id = podId;
                        this.safe = safe;
                        this.ensName = Name.name;
                        baseUrl = "https://orcaprotocol-nft.vercel.app".concat(network === 4 ? '/assets/testnet/' : '/assets/');
                        imageUrl = "".concat(baseUrl).concat(podId.toString(16).padStart(64, '0'), "-image");
                        imageNoTextUrl = "".concat(baseUrl).concat(podId.toString(16).padStart(64, '0'), "-image-no-text");
                        this.imageUrl = imageUrl;
                        this.imageNoTextUrl = imageNoTextUrl;
                        return [2 /*return*/, this];
                }
            });
        }); })();
    }
    /**
     * @ignore
     * Populates the memberEOAs and memberPods fields.
     * The process for fetching either of these fields is the same.
     */
    Pod.prototype.populateMembers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var EOAs, memberPods;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.members) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getMembers()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        EOAs = [];
                        return [4 /*yield*/, Promise.all(this.members.map(function (member) { return __awaiter(_this, void 0, void 0, function () {
                                var pod;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, new Pod(member)];
                                        case 1:
                                            pod = _a.sent();
                                            // If pod is null, it's an EOA.
                                            if (!pod) {
                                                EOAs.push(member);
                                                return [2 /*return*/, pod];
                                            }
                                            return [2 /*return*/, pod];
                                    }
                                });
                            }); }))];
                    case 3:
                        memberPods = (_a.sent()).filter(function (x) { return !!x; });
                        this.memberEOAs = EOAs;
                        this.memberPods = memberPods;
                        return [2 /*return*/];
                }
            });
        });
    };
    return Pod;
}());
exports["default"] = Pod;
